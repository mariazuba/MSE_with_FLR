load("C:/use/OneDrive - AZTI/GESTACOMNX/output/results_SRs.RData")
ls()
ls()
load("C:/use/OneDrive - AZTI/GESTACOMNX/output/results_SRs.RData")
names(min)
load("C:/use/OneDrive - AZTI/GESTACOMNX/output/results_summ_SRs.RData")
fltStk %>% filter(year == 2030)
library(tidyverse)
load("C:/use/OneDrive - AZTI/GESTACOMNX/output/results_summ_SRs.RData")
fltStk %>% filter(year == 2030)
fltStk %>% filter(year == 2030 & fleet == 'OTB_SP')
fltStk %>% filter(year == 2030 & fleet == 'OTB_SP' & stock == 'quotUpt')
fltStk %>% filter(year == 2030 & fleet == 'OTB_SP' & indicator == 'quotaUpt')
fltStk %>% filter(year == 2030 & fleet == 'OTB_SP' & indicator == 'quotaUpt', scenario == 'min')
fltStk %>% filter(year == 2025 & fleet == 'OTB_SP' & indicator == 'quotaUpt', scenario == 'min')
flt %>% filter(year == 2025 & fleet == 'OTB_SP' & indicator == 'quotaUpt', scenario == 'min')
flt %>% filter(year == 2025 & fleet == 'OTB_SP', scenario == 'min')
flt %>% filter(year == 2021 & fleet == 'OTB_SP', scenario == 'min')
flt %>% filter(year == 2025 & fleet == 'OTB_SP', scenario == 'min')
flt %>% filter(year == 2025 & fleet == 'OTB_SP', scenario == 'pre')
flt %>% filter(year == 2025 & fleet == 'OTB_SP', scenario == 'prev')
fltStk %>% filter(year == 2025 & fleet == 'OTB_SP' & indicator == 'quotaUpt', scenario == 'pre')
fltStk %>% filter(year == 2025 & fleet == 'OTB_SP' & indicator == 'quotaUpt', scenario == 'prev')
7200/86
7200/56
40*0.6
19*14
1700*14/12
install.packages("FLCore", repos="http://flr-project.org/R")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("FLCore", repos="http://flr-project.org/R")
source("http://flr-project.org/R/instFLR.R")
2
source("http://flr-project.org/R/instFLR.R")
source("http://flr-project.org/R/instFLR.R")
source("http://flr-project.org/R/instFLR.R")
source("http://flr-project.org/R/instFLR.R")
source("http://flr-project.org/R/instFLR.R")
source("http://flr-project.org/R/instFLR.R")
source("http://flr-project.org/R/instFLR.R")
source("http://flr-project.org/R/instFLR.R")
library(help= FLBEIA)
source("http://flr-project.org/R/instFLR.R")
source("http://flr-project.org/R/instFLR.R")
source("http://flr-project.org/R/instFLR.R")
library(FLAssess)
install.packages("FLAssess", repos="http://flr-project.org/R")
library(FLAssess)
?install.packages
install.packages("FLAssess", repos="http://flr-project.org/R", args = '--no-multiarch')
library(FLAssess)
install.packages("FLAssess",INSTALL_opts="--no-multiarch")
library(FLAssess)
install.packages(repos="http://flr-project.org/R", INSTALL_opts="--no-multiarch")
install.packages(repos="http://flr-project.org/R/FLAssess", INSTALL_opts="--no-multiarch")
install.packages(repos="http://flr-project.org/R/", INSTALL_opts="--no-multiarch")
library(FLAssess)
install.packages(FLAssess, repos="http://flr-project.org/R/", INSTALL_opts="--no-multiarch")
source("http://flr-project.org/R/instFLR.R")
?install.packages
install.packages('FLAssess', repos="http://flr-project.org/R/", INSTALL_opts="--no-multiarch")
library(FLAssess)
install.packages('FLAssess', repos="http://flr-project.org/R/", INSTALL_opts="--no-multiarch")
library(FLAssess)
remotes::install_github("flr/FLAssess", INSTALL_opts="--no-multiarch")
install.packages("remotes")
remotes::install_github("flr/FLAssess", INSTALL_opts="--no-multiarch")
remotes::install_github("flr/FLAssess", INSTALL_opts="--no-multiarch")
remotes::install_github("flr/FLAssess", INSTALL_opts="--no-multiarch")
remotes::install_github("flr/FLAssess", INSTALL_opts="--no-multiarch")
load("C:/Users/dgarcia/Downloads/finaldataextracted.Rdata")
ls()
load("C:/Users/dgarcia/Downloads/finaldataextracted.Rdata")
ls()
names(data)
dim(data)
unique(data$Process)
library(tidyverse)
unique(data$Environmental.Drivers.)
dd <- data %>% filter(Environmental.Drivers.== 'density dependence')
dd
dim(dd)
names(dd)
dd
dd <- as_tibble(dd)
dd
names(dd)
names(dd$Life.stage)
unique(dd$Life.stage)
unique(dd$Title)
length(unique(dd$Title))
unique(dd$Life.stage)
dd <- filter(Life.stage != "early life stages (eggs, larvae)")
dd <- dd %>% filter(Life.stage != "early life stages (eggs, larvae)")
length(unique(dd$Title))
names(dd)
names(dd$sSpecies)
names(dd$Species)
unique((dd$Species)
unique(dd$Species)
dd <- dd %>% filter(Species %in% c("Merluccius merluccius",    "Lepidorhombus whiffiagonis"  )
d0 <- dd %>% filter(Species %in% c("Merluccius merluccius",    "Lepidorhombus whiffiagonis"  )
)
unique(d0$Title)
names(d)
names(dd)
unique(dd$Environmental.Drivers.)
unique(dd$Process)
write.csv(dd, file ='densodependence_literature.csv')
getwd()
remotes::install_github("flr/FLAssess", INSTALL_opts="--no-multiarch")
remotes::install_github("flr/FLAssess", INSTALL_opts="--no-multiarch")
remotes::install_github("flr/FLAssess", INSTALL_opts="--no-multiarch")
library(FLAssess)
setwd("C:/Users/dgarcia/Dropbox/FLBEIA_CursoIEO/Tutorials/02_MSE_with_FLR")
library(FLa4a)
library(FLash)
library(FLXSA)
library(FLBRP)
library(ggplotFL)
data(ple4)
data(ple4.index)
stk <- ple4
idx <- FLIndices(idx=ple4.index)
# Set up the iteration and projection window parameters (years) ----------------
it <- 20                    # iterations
it <- 20                    # iterations
y0 <- range(stk)["minyear"] # initial data year
dy <- range(stk)["maxyear"] # final data year
iy <- dy+1                  # initial year of projection (also intermediate year)
ny <- 12    # number of years to project from initial year
fy <- dy+ny # final year
nsqy <- 3   # number of years to compute status quo metrics
# Set up the catchability submodel with a smoothing spline (setting up a 'list' allows for more than one index)
qmod <- list(~s(age, k=6))
# Set up the fishing mortality submodel as a tensor spline, which allows age and year to interact
fmod <- ~te(replace(age, age>9,9), year, k=c(6,8))
# Set up the MCMC parameters
mcsave <- 100
mcmc   <- it * mcsave
# Fit the model
fit <- sca(stk, idx, fmodel = fmod, qmodel = qmod, fit = "MCMC", mcmc = SCAMCMC(mcmc = mcmc, mcsave = mcsave, mcprobe = 0.4))
# Update the FLStock object
stk <- stk + fit
plot(stk)
# Reduce to keep one iteration only for reference points
stk0 <- qapply(stk, iterMedians)
# Segmented regression to 'estimate' Blim.
srsegreg0 <- fmle(as.FLSR(stk0, model="segreg"), method="L-BFGS-B", lower=c(1e-6, 1e-6), upper=c(max(rec(stk)) * 3, Inf))
plot(srsegreg0)
# Generate stock-recruit residuals for the projection period
srbh.res <- rnorm(it, FLQuant(0, dimnames=list(year=iy:fy)), mean(c(apply(residuals(srbh), 6, sd))))
srbh  <- fmle(as.FLSR(stk,  model="bevholt"), method="L-BFGS-B", lower=c(1e-6, 1e-6), upper=c(max(rec(stk)) * 3, Inf))
srbh0  <- fmle(as.FLSR(stk0,  model="bevholt"), method="L-BFGS-B", lower=c(1e-6, 1e-6), upper=c(max(rec(stk)) * 3, Inf))
plot(srbh0)
# Segmented regression to 'estimate' Blim.
srsegreg0 <- fmle(as.FLSR(stk0, model="segreg"), method="L-BFGS-B", lower=c(1e-6, 1e-6), upper=c(max(rec(stk)) * 3, Inf))
plot(srsegreg0)
# Generate stock-recruit residuals for the projection period
srbh.res <- rnorm(it, FLQuant(0, dimnames=list(year=iy:fy)), mean(c(apply(residuals(srbh), 6, sd))))
# Calculate the reference points
brp  <- brp(FLBRP(stk0, srbh0))
refpts(brp)
Fmsy <- c(refpts(brp)["msy","harvest"])
msy  <- c(refpts(brp)["msy","yield"])
msy
Bmsy <- c(refpts(brp)["msy","ssb"])
Bmsy
Blim <- srsegreg0@params$b[drop=T]
Blim
Bpa  <- Blim*exp(1.654*sqrt(var(ssb(stk)/mean(ssb(stk)))))
# Generate stock-recruit residuals for the projection period
srbh.res <- rnorm(it, FLQuant(0, dimnames=list(year=iy:fy)), mean(c(apply(residuals(srbh), 6, sd))))
# ** set up the operating model for the projection window ** -------------------
#Prepare the FLStock object for projections
stk <- stf(stk, fy-dy, nsqy, nsqy)
fy.dy
fy-dy
stk@stock.wt
stk@m
idcs <- FLIndices()
# Estimate the index catchabilities from the a4a  (without simulation)
# Set up the FLIndices object and populate it (note, FLIndices potentially has more than one index, hence the for loop)
idcs <- FLIndices()
for (i in 1:length(idx)){
#   Set up FLQuants and calculate mean and sd for catchability
lst        <- mcf(list(index(idx[[i]]), stock.n(stk0))) # make FLQuants same dimensions
idx.lq     <- log(lst[[1]]/lst[[2]]) # log catchability of index
idx.qmu    <- idx.qsig <- stock.n(iter(stk,1)) # create quants
idx.qmu[]  <- yearMeans(idx.lq) # allocate same mean-at-age to every year
idx.qsig[] <- sqrt(yearVars(idx.lq)) # allocate same sd-at-age to every year
#   Build index catchability based on lognormal distribution with mean and sd calculated above
idx.q    <- rlnorm(it, idx.qmu, idx.qsig)
idx_temp <- idx.q * stock.n(stk)
idx_temp <- FLIndex(index=idx_temp, index.q=idx.q) # generate initial index
range(idx_temp)[c("startf", "endf")] <- c(0, 0) # timing of index (as proportion of year)
idcs[[i]] <- idx_temp
}
names(idcs) <- names(idx)
idx<-idcs[1]
dnms <- list(iter=1:it, year=years, c("min", "val", "max"))
arr0 <- array(NA, dimnames=dnms, dim=unlist(lapply(dnms, length)))
arr0[,,"val"] <- unlist(values)
arr0 <- aperm(arr0, c(2,3,1))
ctrl <- fwdControl(data.frame(year=years, quantity=quantity, val=NA))
ctrl@trgtArray <- arr0
ctrl
}
# * Control object for projections
# * Observation error model ** -------------------------------------------------
o <- function(stk, idx, assessmentYear, dataYears) {
# dataYears is a position vector, not the years themselves
stk.tmp <- stk[, dataYears]
# add small amount to avoid zeros
catch.n(stk.tmp) <- catch.n(stk.tmp) + 0.1
# Generate the indices - just data years
idx.tmp <- lapply(idx, function(x) x[,dataYears])
# Generate observed index
for (i in 1:length(idx)) index(idx[[i]])[, assessmentYear] <-  stock.n(stk)[, assessmentYear]*index.q(idx[[i]])[, assessmentYear]
return(list(stk=stk.tmp, idx=idx.tmp, idx.om=idx))
}
# * XSA assessment model ** ----------------------------------------------------
xsa <- function(stk, idx){
# Set up XSA settings
control  <- FLXSA.control(tol = 1e-09, maxit=99, min.nse=0.3, fse=2.0,
rage = -1, qage = range(stk)["max"]-1, shk.n = TRUE, shk.f = TRUE,
shk.yrs = 5, shk.ages= 5, window = 100, tsrange = 99, tspower = 0)
# Fit XSA
fit <- FLXSA(stk, idx, control)
# convergence diagnostic (quick and dirty)
maxit <- c("maxit" = fit@control@maxit)
# Update stk
stk   <- transform(stk, harvest = harvest(fit), stock.n = stock.n(fit))
return(list(stk = stk, converge = maxit))
}
# * Control object for projections ** ------------------------------------------
getCtrl <- function(values, quantity, years, it){
dnms <- list(iter=1:it, year=years, c("min", "val", "max"))
arr0 <- array(NA, dimnames=dnms, dim=unlist(lapply(dnms, length)))
arr0[,,"val"] <- unlist(values)
arr0 <- aperm(arr0, c(2,3,1))
ctrl <- fwdControl(data.frame(year=years, quantity=quantity, val=NA))
ctrl@trgtArray <- arr0
ctrl
}
vy <- ac(iy:fy)
iy:fy
vy <- ac(iy:fy)
vy
TAC <- FLQuant(NA, dimnames=list(TAC="all", year=c(dy,vy), iter=1:it))
TAC[,ac(dy)] <- catch(stk)[,ac(dy)]
TAC
TAC[,ac(iy)] <- TAC[,ac(dy)] #assume same TAC in the first intermediate year
TAC[,ac(iy)] <- TAC[,ac(dy)] #assume same TAC in the first intermediate year
TAC
TAC[,ac(dy)] <- 140000
TAC[,ac(iy)] <- TAC[,ac(dy)] #assume same TAC in the first intermediate year
TAC
ctrl <- getCtrl(c(TAC[,ac(iy)]), "catch", iy, it)
trl
ctrl
# Set up the operating model FLStock object
stk.om <- fwd(stk, control=ctrl, sr=srbh, sr.residuals = exp(srbh.res), sr.residuals.mult = TRUE)
# Set up the operating model FLStock object
stk.om <- fwd(stk, control=ctrl, sr=srbh, sr.residuals = exp(srbh.res), sr.residuals.mult = TRUE)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-
# Start the MSE loop ------------------------------------------------------------
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-
set.seed(231) # set seed to ensure comparability between different runs
stk.om
stk.om@stock.om
stk.om@stock.n
# REVISED Dorleta Garcia 2022-11-28
# install.packages(c("ggplot2"))
# install.packages(c("FLa4a","FLash","FLXSA","FLBRP","ggplotFL"), repos="http://flr-project.org/R")
#### Loads all necessary packages ####
library(FLa4a)
library(FLash)
library(FLXSA)
library(FLBRP)
library(ggplotFL)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-
####  CONDITIONING THE OPERATING MODEL ####
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-
# Read in stock assessment data ------------------------------------------------
data(ple4)
data(ple4.index)
stk <- ple4
idx <- FLIndices(idx=ple4.index)
# Set up the iteration and projection window parameters (years) ----------------
it <- 20                    # iterations
y0 <- range(stk)["minyear"] # initial data year
dy <- range(stk)["maxyear"] # final data year
iy <- dy+1                  # initial year of projection (also intermediate year)
ny <- 12    # number of years to project from initial year
fy <- dy+ny # final year
nsqy <- 3   # number of years to compute status quo metrics
# ** Fit stock assessment model a4a ** -----------------------------------------
# Set up the catchability submodel with a smoothing spline (setting up a 'list' allows for more than one index)
qmod <- list(~s(age, k=6))
# Set up the fishing mortality submodel as a tensor spline, which allows age and year to interact
fmod <- ~te(replace(age, age>9,9), year, k=c(6,8))
# Set up the MCMC parameters
mcsave <- 100
mcmc   <- it * mcsave
# Fit the model
fit <- sca(stk, idx, fmodel = fmod, qmodel = qmod, fit = "MCMC", mcmc = SCAMCMC(mcmc = mcmc, mcsave = mcsave, mcprobe = 0.4))
# Update the FLStock object
stk <- stk + fit
plot(stk)
# Reduce to keep one iteration only for reference points
stk0 <- qapply(stk, iterMedians)
# ** Fit the stock-recruit model ** --------------------------------------------
srbh  <- fmle(as.FLSR(stk,  model="bevholt"), method="L-BFGS-B", lower=c(1e-6, 1e-6), upper=c(max(rec(stk)) * 3, Inf))
srbh0  <- fmle(as.FLSR(stk0,  model="bevholt"), method="L-BFGS-B", lower=c(1e-6, 1e-6), upper=c(max(rec(stk)) * 3, Inf))
plot(srbh0)
# Segmented regression to 'estimate' Blim.
srsegreg0 <- fmle(as.FLSR(stk0, model="segreg"), method="L-BFGS-B", lower=c(1e-6, 1e-6), upper=c(max(rec(stk)) * 3, Inf))
plot(srsegreg0)
# Generate stock-recruit residuals for the projection period
srbh.res <- rnorm(it, FLQuant(0, dimnames=list(year=iy:fy)), mean(c(apply(residuals(srbh), 6, sd))))
## ** Calculate reference points ** --------------------------------------------
# Calculate the reference points
brp  <- brp(FLBRP(stk0, srbh0))
refpts(brp)
Fmsy <- c(refpts(brp)["msy","harvest"])
msy  <- c(refpts(brp)["msy","yield"])
Bmsy <- c(refpts(brp)["msy","ssb"])
Blim <- srsegreg0@params$b[drop=T]
Bpa  <- Blim*exp(1.654*sqrt(var(ssb(stk)/mean(ssb(stk)))))
# ** set up the operating model for the projection window ** -------------------
#Prepare the FLStock object for projections
stk <- stf(stk, fy-dy, nsqy, nsqy)
stk@stock.wt
stk@m
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-
## SET UP OBSERVATION ERROR MODEL ELEMENTS -------------------------------------
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-
# Estimate the index catchabilities from the a4a  (without simulation)
# Set up the FLIndices object and populate it (note, FLIndices potentially has more than one index, hence the for loop)
idcs <- FLIndices()
for (i in 1:length(idx)){
#   Set up FLQuants and calculate mean and sd for catchability
lst        <- mcf(list(index(idx[[i]]), stock.n(stk0))) # make FLQuants same dimensions
idx.lq     <- log(lst[[1]]/lst[[2]]) # log catchability of index
idx.qmu    <- idx.qsig <- stock.n(iter(stk,1)) # create quants
idx.qmu[]  <- yearMeans(idx.lq) # allocate same mean-at-age to every year
idx.qsig[] <- sqrt(yearVars(idx.lq)) # allocate same sd-at-age to every year
#   Build index catchability based on lognormal distribution with mean and sd calculated above
idx.q    <- rlnorm(it, idx.qmu, idx.qsig)
idx_temp <- idx.q * stock.n(stk)
idx_temp <- FLIndex(index=idx_temp, index.q=idx.q) # generate initial index
range(idx_temp)[c("startf", "endf")] <- c(0, 0) # timing of index (as proportion of year)
idcs[[i]] <- idx_temp
}
names(idcs) <- names(idx)
idx<-idcs[1]
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-
# SET UP MSE LOOP ---------------------------------------------------------------
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-
# Needed Functions:
# * Observation error model
# * XSA assessment model
# * Control object for projections
# * Observation error model ** -------------------------------------------------
o <- function(stk, idx, assessmentYear, dataYears) {
# dataYears is a position vector, not the years themselves
stk.tmp <- stk[, dataYears]
# add small amount to avoid zeros
catch.n(stk.tmp) <- catch.n(stk.tmp) + 0.1
# Generate the indices - just data years
idx.tmp <- lapply(idx, function(x) x[,dataYears])
# Generate observed index
for (i in 1:length(idx)) index(idx[[i]])[, assessmentYear] <-  stock.n(stk)[, assessmentYear]*index.q(idx[[i]])[, assessmentYear]
return(list(stk=stk.tmp, idx=idx.tmp, idx.om=idx))
}
# * XSA assessment model ** ----------------------------------------------------
xsa <- function(stk, idx){
# Set up XSA settings
control  <- FLXSA.control(tol = 1e-09, maxit=99, min.nse=0.3, fse=2.0,
rage = -1, qage = range(stk)["max"]-1, shk.n = TRUE, shk.f = TRUE,
shk.yrs = 5, shk.ages= 5, window = 100, tsrange = 99, tspower = 0)
# Fit XSA
fit <- FLXSA(stk, idx, control)
# convergence diagnostic (quick and dirty)
maxit <- c("maxit" = fit@control@maxit)
# Update stk
stk   <- transform(stk, harvest = harvest(fit), stock.n = stock.n(fit))
return(list(stk = stk, converge = maxit))
}
# * Control object for projections ** ------------------------------------------
getCtrl <- function(values, quantity, years, it){
dnms <- list(iter=1:it, year=years, c("min", "val", "max"))
arr0 <- array(NA, dimnames=dnms, dim=unlist(lapply(dnms, length)))
arr0[,,"val"] <- unlist(values)
arr0 <- aperm(arr0, c(2,3,1))
ctrl <- fwdControl(data.frame(year=years, quantity=quantity, val=NA))
ctrl@trgtArray <- arr0
ctrl
}
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-
# MSE initialisation -----------------------------------------------------------
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-
vy <- ac(iy:fy)
TAC <- FLQuant(NA, dimnames=list(TAC="all", year=c(dy,vy), iter=1:it))
TAC[,ac(dy)] <- 140000
TAC[,ac(iy)] <- TAC[,ac(dy)] #assume same TAC in the first intermediate year
ctrl <- getCtrl(c(TAC[,ac(iy)]), "catch", iy, it)
?fwd
??fwd
?Flash:::fwd
?FLash:::fwd
?FLash::fwd
stk@stock.n
# Set up the operating model FLStock object
stk.om <- fwd(stk, control=ctrl, sr=srbh, sr.residuals = exp(srbh.res), sr.residuals.mult = TRUE)
stk.om@stock.n
ctrl
stk.om@stock
stk.om@catch
ctrl
vy[-length(vy)]
set.seed(231) # set seed to ensure comparability between different runs
for(i in vy[-length(vy)]){
# set up simulations parameters
ay <- an(i)
cat(i, " < ")
flush.console()
vy0 <- 1:(ay-y0)              # data years (positions vector) - one less than current year
sqy <- (ay-y0-nsqy+1):(ay-y0) # status quo years (positions vector) - one less than current year
# apply observation error
oem    <- o(stk.om, idx, i, vy0)
stk.mp <- oem$stk
idx.mp <- oem$idx
idx    <- oem$idx.om
# perform assessment
out.assess <- xsa(stk.mp, idx.mp)
stk.mp     <- out.assess$stk
# apply ICES MSY-like Rule to obtain Ftrgt (note this is not the ICES MSY rule, but is similar)
flag  <- ssb(stk.mp)[,ac(ay-1)]<Bpa
Ftrgt <- ifelse(flag,ssb(stk.mp)[,ac(ay-1)]*Fmsy/Bpa,Fmsy)
# project the perceived stock to get the TAC for ay+1
fsq.mp    <- yearMeans(fbar(stk.mp)[,sqy]) # Use status quo years defined above
ctrl      <- getCtrl(c(fsq.mp, Ftrgt), "f", c(ay, ay+1), it)
stk.mp    <- stf(stk.mp, 2)
gmean_rec <- c(exp(yearMeans(log(rec(stk.mp)))))
stk.mp    <- fwd(stk.mp, control=ctrl, sr=list(model="mean", params = FLPar(gmean_rec,iter=it)))
TAC[,ac(ay+1)] <- catch(stk.mp)[,ac(ay+1)]
# apply the TAC to the operating model stock and project the population one year forward.
ctrl   <- getCtrl(c(TAC[,ac(ay+1)]), "catch", ay+1, it)
stk.om <- fwd(stk.om, control=ctrl,sr=srbh, sr.residuals = exp(srbh.res), sr.residuals.mult = TRUE)
}
save(stk.om, file = 'C:/users/dgarcia/Dropbox/FLBEIA_CursoIEO/Tutorials/02_MSE_with_FLR/stk.RData')
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-
# PERFORMANCE STATISTICS
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-
# Some example performance statstics, but first isolate the projection period
stk.tmp <- window(stk.om,start=iy)
iy
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-
# PERFORMANCE STATISTICS
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-
# Some example performance statstics, but first isolate the projection period
stk.tmp <- window(stk.om,start=iy)
stk.tmp
stk.tmp#m
stk.tmp@m
(ssb(stk.tmp)/Bmsy)<1
((ssb(stk.tmp)/Bmsy)<1)[,'2024']
((ssb(stk.tmp)/Bmsy)<1)[,'2024', drop=T]
it
# annual probability of being below Blim
risky.Bmsy <- iterSums((ssb(stk.tmp)/Bmsy)<1)/(it*ny)
risky.Bpa  <- iterSums((ssb(stk.tmp)/Bpa)<1)/(it*ny)
risky.Blim <- iterSums((ssb(stk.tmp)/Blim)<1)/(it*ny)
risky.Bmsy
# annual probability of being below Blim
risky.Bmsy <- iterSums((ssb(stk.tmp)/Bmsy)<1)/it
risky.Bpa  <- iterSums((ssb(stk.tmp)/Bpa)<1)/it
risky.Blim <- iterSums((ssb(stk.tmp)/Blim)<1)/it
risky.Bmsy
risky.Bpa  <- iterSums((ssb(stk.tmp)/Bpa)<1)/it
risky.Bpa
risky.Blim
# mean probability of being below Bmsy in the first half of the projection period
mean(risky.Bmsy [,1:floor(length(risky.Bmsy)/2)])
# ...and second half
mean(risky.Bmsy [,(floor(length(risky.Bmsy)/2)+1):length(risky.Bmsy)])
# plot of SSB relative to Bmsy
boxplot(data~year,data=as.data.frame(ssb(stk.tmp)),main="SSB")
abline(h=Bmsy,col="red")
plot(FLStocks(stk.om=stk.om, stk.mp=stk.mp)) + theme(legend.position="top") + geom_vline(aes(xintercept=2009))
plot(FLStocks(stk.om = stk.om,
stk.om.sr = stk.om.sr,
stk.om.im.err =  stk.om.im.err,
stk.om.m = stk.om.m,
stk.om.merr = stk.om.merr,
stk.om.obs.err.id = stk.om.obs.err.id)) + theme(legend.position="top") + geom_vline(aes(xintercept=2018))
load('C:/users/dgarcia/Dropbox/FLBEIA_CursoIEO/Tutorials/02_MSE_with_FLR/stk_exe1.RData')
load('C:/users/dgarcia/Dropbox/FLBEIA_CursoIEO/Tutorials/02_MSE_with_FLR/stk_exe2.RData')
load('C:/users/dgarcia/Dropbox/FLBEIA_CursoIEO/Tutorials/02_MSE_with_FLR/stk_exe3.RData')
load('C:/users/dgarcia/Dropbox/FLBEIA_CursoIEO/Tutorials/02_MSE_with_FLR/stk_exe4.RData')
load('C:/users/dgarcia/Dropbox/FLBEIA_CursoIEO/Tutorials/02_MSE_with_FLR/stk_exe5.RData')
plot(FLStocks(stk.om = stk.om,
stk.om.sr = stk.om.sr,
stk.om.im.err =  stk.om.im.err,
stk.om.m = stk.om.m,
stk.om.merr = stk.om.merr,
stk.om.obs.err.id = stk.om.obs.err.id)) + theme(legend.position="top") + geom_vline(aes(xintercept=2018))
library(FLBEIA)
library(FLBEIA)
